=== Contents of app/app/asgi.py ===
"""
ASGI config for app project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'app.settings')

application = get_asgi_application()

=== Contents of app/app/settings.py ===
"""
Django settings for app project.

Generated by 'django-admin startproject' using Django 4.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/4.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-xz=i502*o3k%v$lr6jqgu96e)a!@mn(a!x5+%@1=-1tbrf*$05'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'community',
    'documents',
    'health_records',
    'sqloniris',
    'interop',
    'rest_framework'
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware'
]

REST_FRAMEWORK = {
    # Use Django's standard `django.contrib.auth` permissions,
    # or allow read-only access for unauthenticated users.
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 20
}

ROOT_URLCONF = 'app.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'app.wsgi.application'


# Database
# https://docs.djangoproject.com/en/4.0/ref/settings/#databases

DATABASES = {
    "default": {
        "ENGINE": "django_iris",
        "EMBEDDED": True,
        "NAMESPACE": "IRISAPP",
        "USER":"SuperUser",
        "PASSWORD":"SYS",
    }
}


# Password validation
# https://docs.djangoproject.com/en/4.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/4.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/4.0/howto/static-files/


STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'static'
STATICFILES_DIRS = [
    BASE_DIR / 'frontend' / 'dist',
]

# Default primary key field type
# https://docs.djangoproject.com/en/4.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

=== Contents of app/app/urls.py ===
"""app URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/4.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path,include
from rest_framework import routers
from community.views import PostViewSet, CommentViewSet

from sqloniris.views import index
from interop.views import index as interop_index

from documents.views import DocumentViewSet
from health_records.views import EHRViewSet

router = routers.DefaultRouter()
router.register(r'posts', PostViewSet)
router.register(r'comments', CommentViewSet)
router.register(r'documents', DocumentViewSet)
router.register(r'health_records', EHRViewSet)




urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),
    path('iris/', index),
    path('interop/', interop_index),
    path('community/', include('community.urls')),
]

=== Contents of app/app/wsgi.py ===
"""
WSGI config for app project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'app.settings')

application = get_wsgi_application()

=== Contents of app/community/admin.py ===
from django.contrib import admin

# Register your models here.
from community.models import Post, Comment

admin.site.register(Post)
admin.site.register(Comment)

=== Contents of app/community/models.py ===
from django.db import models

# Create your models here.
class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()

class Comment(models.Model):
    content = models.TextField()
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')


=== Contents of app/community/serializers.py ===
from rest_framework import serializers
from community.models import Post, Comment

class PostSerializer(serializers.ModelSerializer):
    class Meta:
        model = Post
        fields = ('id', 'title', 'content', 'comments')

class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields = ('id', 'content', 'post')

=== Contents of app/community/tests.py ===
from django.test import TestCase

# Create your tests here.

=== Contents of app/community/urls.py ===
from django.urls import path
from .views import index

urlpatterns = [
    path('', index, name='index'),
]

=== Contents of app/community/views.py ===
from django.shortcuts import render
from rest_framework import viewsets
from django.http import HttpResponse
import os
from django.conf import settings


# Import the Post and Comment models
from community.models import Post, Comment

# Import the Post and Comment serializers
from community.serializers import PostSerializer, CommentSerializer

# Create your views here.
class PostViewSet(viewsets.ModelViewSet):
    queryset = Post.objects.all()
    serializer_class = PostSerializer

class CommentViewSet(viewsets.ModelViewSet):
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer

def index(request):
    with open(os.path.join(settings.BASE_DIR, 'static/index.html')) as f:
        return HttpResponse(f.read())
=== Contents of app/documents/embedding.py ===
from llama_index.embeddings.huggingface import HuggingFaceEmbedding
from llama_index.core import Settings

Settings.embed_model = HuggingFaceEmbedding(
    model_name="BAAI/bge-small-en-v1.5"
)

def generate_embedding(text):
    embedding = Settings.embed_model.embed([text])
    return embedding[0]

=== Contents of app/documents/models.py ===
from django.db import models

class Document(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    embedding = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

class Conversation(models.Model):
    model_name = models.CharField(max_length=100)
    prompt = models.TextField()
    response = models.TextField()
    documents = models.ManyToManyField(Document)
    created_at = models.DateTimeField(auto_now_add=True)

=== Contents of app/documents/rag.py ===
import os
#from dotenv import load_dotenv
from llama_index.core import StorageContext
from llama_index.core import VectorStoreIndex
from llama_iris import IRISVectorStore
from .models import Document
from .embedding import generate_embedding

#load_dotenv(override=True)

#CONNECTION_STRING = os.getenv("CONNECTION_STRING")

def query_rag_model(prompt, model_name):
    documents = Document.objects.all()
    vector_store = IRISVectorStore.from_params(
        connection_string=iris.connect("localhost:1972/USER", "_system", "SYS"),
        table_name="documents",
        embed_dim=768,  # Assuming BAAI/bge-small-en-v1.5 embedding dimension
    )
    storage_context = StorageContext.from_defaults(vector_store=vector_store)
    index = VectorStoreIndex.from_documents(
        documents,
        storage_context=storage_context,
        show_progress=True,
    )
    query_engine = index.as_query_engine()
    response = query_engine.query(prompt)
    related_docs = perform_vector_search(generate_embedding(prompt))
    return str(response), related_docs

def perform_vector_search(embedding):
    connection = iris.connect("localhost:1972/USER", "_system", "SYS")
    cursor = connection.cursor()
    query = """
    SELECT UID, Embedding FROM Sample.Embeddings
    ORDER BY VECTOR_DOT_PRODUCT(Embedding, TO_VECTOR(?,double)) DESC
    LIMIT 5
    """
    params = [str(embedding)]
    cursor.execute(query, params)
    related_docs = []
    for row in cursor:
        uid = row[0]
        doc = Document.objects.get(id=uid)
        related_docs.append(doc)
    return related_docs

=== Contents of app/documents/serializers.py ===
from rest_framework import serializers
from .models import Document, Conversation

class DocumentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Document
        fields = '__all__'

class ConversationSerializer(serializers.ModelSerializer):
    documents = DocumentSerializer(many=True, read_only=True)
    
    class Meta:
        model = Conversation
        fields = '__all__'

=== Contents of app/documents/urls.py ===
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DocumentViewSet, ConversationViewSet

router = DefaultRouter()
router.register(r'documents', DocumentViewSet)
router.register(r'conversations', ConversationViewSet)

urlpatterns = [
    path('', include(router.urls)),
]

=== Contents of app/documents/views.py ===
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from .models import Document, Conversation
from .serializers import DocumentSerializer, ConversationSerializer
from .embedding import generate_embedding
from .rag import query_rag_model

class DocumentViewSet(viewsets.ModelViewSet):
    queryset = Document.objects.all()
    serializer_class = DocumentSerializer

    def perform_create(self, serializer):
        content = serializer.validated_data['content']
        embedding = generate_embedding(content)
        serializer.save(embedding=embedding)

class ConversationViewSet(viewsets.ModelViewSet):
    queryset = Conversation.objects.all()
    serializer_class = ConversationSerializer

    @action(detail=False, methods=['post'])
    def query(self, request):
        prompt = request.data.get('prompt')
        model_name = request.data.get('model_name')
        response, related_docs = query_rag_model(prompt, model_name)
        conversation = Conversation.objects.create(
            model_name=model_name,
            prompt=prompt,
            response=response
        )
        conversation.documents.set(related_docs)
        conversation.save()
        serializer = self.get_serializer(conversation)
        return Response(serializer.data)

=== Contents of app/frontend/babel.config.js ===
module.exports = {
  presets: [
    '@vue/cli-plugin-babel/preset'
  ]
}

=== Contents of app/frontend/jsconfig.json ===
{
  "compilerOptions": {
    "target": "es5",
    "module": "esnext",
    "baseUrl": "./",
    "moduleResolution": "node",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
    "lib": [
      "esnext",
      "dom",
      "dom.iterable",
      "scripthost"
    ]
  }
}

=== Contents of app/frontend/package.json ===
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "core-js": "^3.8.3",
    "vue": "^3.2.13",
    "vue-router": "^4.0.13"
  },
  "devDependencies": {
    "@babel/core": "^7.12.16",
    "@babel/eslint-parser": "^7.12.16",
    "@vue/cli-plugin-babel": "~5.0.0",
    "@vue/cli-plugin-eslint": "~5.0.0",
    "@vue/cli-service": "~5.0.0",
    "eslint": "^7.32.0",
    "eslint-plugin-vue": "^8.0.3"
  },
  "eslintConfig": {
    "root": true,
    "env": {
      "node": true
    },
    "extends": [
      "plugin:vue/vue3-essential",
      "eslint:recommended"
    ],
    "parserOptions": {
      "parser": "@babel/eslint-parser"
    },
    "rules": {}
  },
  "browserslist": [
    "> 1%",
    "last 2 versions",
    "not dead",
    "not ie 11"
  ]
}

=== Contents of app/frontend/public/index.html ===
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <link rel="icon" href="<%= BASE_URL %>favicon.ico">
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>We're sorry but <%= htmlWebpackPlugin.options.title %> doesn't work properly without JavaScript enabled. Please enable it to continue.</strong>
    </noscript>
    <div id="app"></div>
    <!-- built files will be auto injected -->
  </body>
</html>

=== Contents of app/frontend/README.md ===
# frontend

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Lints and fixes files
```
npm run lint
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

=== Contents of app/frontend/src/App.vue ===
<template>
  <div id="app">
    <router-view />
  </div>
</template>

<script>
export default {
  name: 'App',
};
</script>

<style>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}
</style>

=== Contents of app/frontend/src/main.js ===
import { createApp } from 'vue';
import App from './App.vue';
import router from './router';

createApp(App).use(router).mount('#app');

File app/frontend/components/ConversationManager.vue does not exist.
File app/frontend/components/DocumentManager.vue does not exist.
File app/frontend/router/index.js does not exist.
=== Contents of app/health_records/models.py ===
from django.db import models

class ElectronicHealthRecord(models.Model):
    patient_id = models.CharField(max_length=50)
    record_data = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

=== Contents of app/health_records/serializers.py ===
from rest_framework import serializers
from .models import ElectronicHealthRecord

class EHRSerializer(serializers.ModelSerializer):
    class Meta:
        model = ElectronicHealthRecord
        fields = '__all__'

=== Contents of app/interop/apps.py ===
from django.apps import AppConfig


class InteropConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'interop'

=== Contents of app/interop/bo.py ===
import json
import dataclasses

from iop import BusinessOperation

from msg import HttpMessageRequest, HttpMessageResponse

class BO(BusinessOperation):
    def on_http_request(self, message_request: HttpMessageRequest)->HttpMessageResponse:
        # Create a new response
        # Where the body contains the a json with the message_request attributes
        response = HttpMessageResponse(
            status=200,
            headers={'Content-Type': 'application/json'},
            body=json.dumps(dataclasses.asdict(message_request))
        )
        return response
=== Contents of app/interop/bs.py ===
from iop import BusinessService
from msg import HttpMessageRequest, HttpMessageResponse
from django.core.handlers.wsgi import WSGIRequest

class BS(BusinessService):
    def on_process_input(self, message_input:WSGIRequest)->HttpMessageResponse:
        # Create a new HttpMessageRequest
        msg = HttpMessageRequest(
            method=message_input.method,
            url=message_input.path,
            headers={k: v for k, v in message_input.headers.items() if k != 'content-length'},
            body=message_input.body.decode('utf-8')
        )
        self.log_info(f"Request: {msg}")
        response = self.send_request_sync('BO', msg)
        return response
=== Contents of app/interop/msg.py ===
from iop import Message
from dataclasses import dataclass

@dataclass
class HttpMessageRequest(Message):
    method: str
    url: str
    headers: dict
    body: str

@dataclass
class HttpMessageResponse(Message):
    status: int
    headers: dict
    body: str
=== Contents of app/interop/settings.py ===
from bo import BO
from bs import BS

CLASSES = {
    'Python.BO': BO,
    'Python.BS': BS
}

PRODUCTIONS = [
    {
    "Python.Production": {
        "@Name": "Python.Production",
        "@LogGeneralTraceEvents": "false",
        "Description": "",
        "ActorPoolSize": "1",
        "Item": [
            {
                "@Name": "BS",
                "@ClassName": "Python.BS",
                "@PoolSize": "1",
                "@Enabled": "true",
            },
            {
                "@Name": "BO",
                "@ClassName": "Python.BO",
                "@PoolSize": "1",
                "@Enabled": "true",

            }
        ]
    }
}
]
=== Contents of app/interop/views.py ===
from django.http import HttpResponse

from iop import Director

bs = Director.create_python_business_service('BS')

def index(request):
    result = bs.on_process_input(request)
    return HttpResponse(result)

=== Contents of app/manage.py ===
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'app.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

=== Contents of app/sqloniris/apps.py ===
from django.apps import AppConfig


class SqlonirisConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sqloniris'

=== Contents of app/sqloniris/views.py ===
from django.http import JsonResponse

import iris

def index(request):
    query = "SELECT top 10 * FROM %Dictionary.ClassDefinition"
    rs = iris.sql.exec(query)
    # Convert the result to a list of dictionaries
    result = []
    for row in rs:
        result.append(row)
    return JsonResponse(result, safe=False)

=== Contents of docker-compose.yml ===
version: '3.6'
services:
  iris:
    build: 
      context: .
      dockerfile: Dockerfile
    restart: always
    environment:
      - ISC_CPF_MERGE_FILE=/irisdev/app/merge.cpf
    command: 
      --check-caps false
    ports: 
      - 1972
      - 53795:52773
      - 8001:8001
      - 53773
    volumes:
      - ./:/irisdev/app

=== Contents of Dockerfile ===
ARG IMAGE=containers.intersystems.com/intersystems/iris-community:latest-preview
FROM $IMAGE 

WORKDIR /irisdev/app

## Python stuff
ENV IRISUSERNAME "SuperUser"
ENV IRISPASSWORD "SYS"
ENV IRISNAMESPACE "IRISAPP"

ENV PYTHON_PATH=/usr/irissys/bin/
ENV LD_LIBRARY_PATH=${ISC_PACKAGE_INSTALLDIR}/bin:${LD_LIBRARY_PATH}

ENV PATH "/home/irisowner/.local/bin:/usr/irissys/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/home/irisowner/bin"

COPY . .

USER root

# Remove EXTERNAL-MANAGER from the system
RUN rm -f /usr/lib/python3.12/EXTERNALLY-MANAGED

# Update package and install sudo
RUN apt-get update && apt-get install -y \
	git \
	nano \
	sudo && \
	/bin/echo -e ${ISC_PACKAGE_MGRUSER}\\tALL=\(ALL\)\\tNOPASSWD: ALL >> /etc/sudoers && \
	sudo -u ${ISC_PACKAGE_MGRUSER} sudo echo enabled passwordless sudo-ing for ${ISC_PACKAGE_MGRUSER}

USER ${ISC_PACKAGE_MGRUSER}

RUN pip3 install -r requirements.txt

# change the entrypoint to run iris and the python script
ENTRYPOINT [ "/irisdev/app/entrypoint.sh" ]
=== Contents of entrypoint.sh ===
#!/bin/sh

# start iris
/iris-main "$@" &

# wait for iris to be ready
/usr/irissys/dev/Cloud/ICM/waitISC.sh

# init iop
iop --init

# load production
iop -m /irisdev/app/app/interop/settings.py

# start production
iop --start Python.Production --detach

# Move to the app directory
cd /irisdev/app/app

# python manage.py flush --no-input
python3 manage.py migrate
# create superuser
export DJANGO_SUPERUSER_PASSWORD=SYS
python3 manage.py createsuperuser --no-input --username SuperUser --email admin@admin.fr

# load demo data
python3 manage.py loaddata community/fixtures/demo.json

# collect static files
python3 manage.py collectstatic --no-input --clear

# open log in stdout
iop --log
=== Contents of README.md ===
# iris-django-template

![django_logo](https://www.djangoproject.com/m/img/logos/django-logo-negative.png)

## Description

This is a template for an Django application that can be deployed in IRIS as an native Web Application.

## Installation

1. Clone the repository
2. Create a virtual environment
3. Install the requirements
4. Run the docker-compose file

```bash
git clone
cd iris-django-template
python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
docker-compose up
```

## Usage

The base URL is `http://localhost:53795/django/`.

### Endpoints

- `/iris` - Returns a JSON object with the top 10 classes present in the IRISAPP namespace.
- `/interop` - A ping endpoint to test the interoperability framework of IRIS.
- `/api/posts` - A simple CRUD endpoint for a Post object.
- `/api/comments` - A simple CRUD endpoint for a Comment object.

## How to develop from this template

See WSGI introduction article: [wsgi-introduction](https://community.intersystems.com/post/wsgi-support-introduction).

TL;DR : You can toggle the `DEBUG` flag in the Security portal to make changes to be reflected in the application as you develop.

## Code presentation

The Django application is structured as follows:

- `app` - Django project folder
  - `app` - Django app folder for configuration
    - `settings.py` - Django settings file
    - `urls.py` - Django URL configuration file to connect the views to the URLs
    - `wsgi.py` - Django WSGI file
    - `asgi.py` - Django ASGI file
  - `community` - Django app folder for the community app, crud on Post and Comment objects
    - `models.py` - Django models file for the Post and Comment objects
    - `views.py` - Django views file to access the Post and Comment objects
    - `serializers.py` - Django serializers file for the Post and Comment objects
    - `admin.py` - Django admin file add crud to the admin interface
    - `migrations` - Django migrations folder to build the database
    - `fixtures` - Django fixtures folder demo data 
  - `sqloniris` - Django app folder for the SQL on IRIS app
    - `views.py` - Django views file to query the IRISAPP namespace
    - `apps.py` - Django app configuration file
  - `interop` - Django app folder for the interoperability app
    - `views.py` - Django views file to test the interoperability framework
    - `apps.py` - Django app configuration file
  - `manage.py` - Django management file

### `app/settings.py`

This file contains the Django settings for the application.

```python
...

# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'community',
    'sqloniris',
    'interop',
    'rest_framework'
]

...

REST_FRAMEWORK = {
    # Use Django's standard `django.contrib.auth` permissions,
    # or allow read-only access for unauthenticated users.
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly'
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.LimitOffsetPagination',
    'PAGE_SIZE': 20
}

...

DATABASES = {
    "default": {
        "ENGINE": "django_iris",
        "EMBEDDED": True,
        "NAMESPACE": "IRISAPP",
        "USER":"SuperUser",
        "PASSWORD":"SYS",
    }
}
```

Few important settings to note:

- `INSTALLED_APPS` - Contains the list of installed apps in the Django project.
  - `community` - The Django app for the CRUD operations on the Post and Comment objects.
  - `sqloniris` - The Django app for the SQL on IRIS operations.
  - `interop` - The Django app for the interoperability operations.
  - `rest_framework` - The Django REST framework for the REST API.
- `REST_FRAMEWORK` - Contains the settings for the Django REST framework.
  - `DEFAULT_PERMISSION_CLASSES` - Only authenticated users can perform CRUD operations.
  - `DEFAULT_PAGINATION_CLASS` - The pagination class for the REST API.
- `DATABASES` - Contains the settings for the IRIS database connection.
  - Here we are using the `django_iris` engine to connect to the IRIS database.

### `app/urls.py`

This file contains the URL configuration for the Django application.

```python
from django.contrib import admin
from django.urls import path,include
from rest_framework import routers
from community.views import PostViewSet, CommentViewSet
from sqloniris.views import index
from interop.views import index as interop_index

router = routers.DefaultRouter()
router.register(r'posts', PostViewSet)
router.register(r'comments', CommentViewSet)


urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),
    path('iris/', index),
    path('interop/', interop_index)
]
```

- `router` - Contains the default router for the REST API.
- `routeer.register` - Registers the Post and Comment viewsets to the router.
- `urlpatterns` - Contains the URL patterns for the Django application.
  - `/admin/` - The Django admin interface.
  - `/api/` - The REST API for the Post and Comment objects.
  - `/iris/` - The SQL on IRIS endpoint.
  - `/interop/` - The interoperability endpoint.

### `app/wsgi.py`

This file contains the WSGI configuration for the Django application.

This is the file that we have to provide to IRIS to run the Django application.

In the `Security->Applications->Web Applications` section, we have to provide the path to this file.

- **Application Name**
  - `app.wsgi`
- **Callable Name**
  - `application`
- **WSGI App directory**
  - `/irisdev/app/app`

### `community/models.py`

This file contains the Django models for the Post and Comment objects.

```python
from django.db import models

# Create your models here.
class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()

class Comment(models.Model):
    content = models.TextField()
    post = models.ForeignKey(Post, on_delete=models.CASCADE, related_name='comments')
```

- `Post` - The model for the Post object.
  - `title` - The title of the post.
  - `content` - The content of the post.
- `Comment` - The model for the Comment object.
  - `content` - The content of the comment.
  - `post` - The foreign key to the Post object.
  - `related_name` - The related name for the comments.

### `community/seializers.py`

This file contains the Django serializers for the Post and Comment objects.

Using the Django REST framework, we can serialize the Django models to JSON objects.

```python
from rest_framework import serializers
from community.models import Post, Comment

class PostSerializer(serializers.ModelSerializer):
    class Meta:
        model = Post
        fields = ('id', 'title', 'content', 'comments')

class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields = ('id', 'content', 'post')
```

- `PostSerializer` - The serializer for the Post object.
- `CommentSerializer` - The serializer for the Comment object.
- `fields` - The fields to be serialized.

### `community/views.py`

This file contains the Django views for the Post and Comment objects.

Using the Django REST framework, we can create CRUD operations for the Django models.

```python
from django.shortcuts import render
from rest_framework import viewsets

# Import the Post and Comment models
from community.models import Post, Comment

# Import the Post and Comment serializers
from community.serializers import PostSerializer, CommentSerializer

# Create your views here.
class PostViewSet(viewsets.ModelViewSet):
    queryset = Post.objects.all()
    serializer_class = PostSerializer

class CommentViewSet(viewsets.ModelViewSet):
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer
```

- `PostViewSet` - The viewset for the Post object.
- `CommentViewSet` - The viewset for the Comment object.
- `queryset` - The queryset for the viewset.
- `serializer_class` - The serializer class for the viewset.

### `sqloniris/views.py`

This file contains the Django views for the SQL on IRIS operations.

```python
from django.http import JsonResponse

import iris

def index(request):
    query = "SELECT top 10 * FROM %Dictionary.ClassDefinition"
    rs = iris.sql.exec(query)
    # Convert the result to a list of dictionaries
    result = []
    for row in rs:
        result.append(row)
    return JsonResponse(result, safe=False)
```

- `index` - The view for the SQL on IRIS operation.
- `query` - The SQL query to be executed on the IRIS database.
- `rs` - The result set from the query.
- `result` - The list of list from the result set.
- `JsonResponse` - The JSON response for the view, safe is set to False to allow list of list.

### `interop/views.py`

This file contains the Django views for the interoperability operations.

```python
from django.http import HttpResponse

from iop import Director

bs = Director.create_python_business_service('BS')

def index(request):
    result = bs.on_process_input(request)
    return HttpResponse(result, safe=False)
```

- `bs` - The business service object created using the `Director` class.
- `index` - The view for the interoperability operation.
- `result` - The result from the business service.

NB : we don't use `JsonResponse` to simplify the code, we can use it if we want to return a JSON object.

## Troubleshooting

### How to run the Django application in a standalone mode

To run the Django application in a standalone mode, we can use the following command:

```bash
cd /irisdev/app/app
python3 manage.py runserver 8001
```

This will run the Django application on the default port `8001`.


NB : You must be inside of the container to run this command.

```bash
docker exec -it iris-django-template-iris-1 bash
```

### Restart the application in IRIS

Be in `DEBUG` mode make multiple calls to the application, and the changes will be reflected in the application.

### How to access the IRIS Management Portal

You can access the IRIS Management Portal by going to `http://localhost:53795/csp/sys/UtilHome.csp`.

### Run this template locally

For this you need to have IRIS installed on your machine.

Next you need to create a namespace named `IRISAPP`.

Install the requirements.

```bash
# Move to the app directory
cd /irisdev/app/app

# python manage.py flush --no-input
python3 manage.py migrate
# create superuser
export DJANGO_SUPERUSER_PASSWORD=SYS
python3 manage.py createsuperuser --no-input --username SuperUser --email admin@admin.fr

# load demo data
python3 manage.py loaddata community/fixtures/demo.json

# collect static files
python3 manage.py collectstatic --no-input --clear

# init iop
iop --init

# load production
iop -m /irisdev/app/app/interop/settings.py

# start production
iop --start Python.Production
```

### How to serve static files

To serve the static files in the Django application, we can use the following command:

```bash
cd /irisdev/app
python3 manage.py collectstatic
```

This will collect the static files from the Django application and serve them in the `/irisdev/app/static` directory.

To publish the static files in IRIS, configure the `Security->Applications->Web Applications` section.

![web_applications](./misc/static.png)
=== Contents of requirements.txt ===
django>=5.0.0
djangorestframework

## iris community package
# db-api
intersystems_iris @ https://github.com/intersystems-community/intersystems-irispython/releases/download/3.7.7/intersystems_iris-3.7.7-py3-none-any.whl
# django-iris
django-iris>=0.2.5b4
# iop - interoperability on python
iris-pex-embedded-python>=2.0.0

#for RAG
llama-index
transformers
llama-index-embeddings-huggingface
python-dotenv
llama-iris

## for testing
pytest

